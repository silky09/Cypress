features:
1. Cypress takes SS as your tests run.
2. after execution, you can see all SS/videos in command log
3. it has debugging features
4. it has automatic wait features (no need to add additional wait)
5. it interacts with browser directly (does not use webdriver). so it is fast, consistent and reliable.
6. it has cross browser testing supports.
7. it is used to write all types of tests:
--> End-to-End tests
--> Integration tests
--> Unit tests

Prerequisite - Setting up Cypress environment:
--> node -v
--> npm -v   (node package manager)
pip : package installer for Python

Project Setup:
1. install Node.js
2. install VS code

3. in vscode terminal, first run command 
---> npm init -y (y means yes)
4. install cypress within local folder/Project to access easily
--> npm install cypress (incase not installed then use: npm install cypress@latest version number)
--> npx cypress -v
------>  (if required to install typescript use: npm install typescript)
then run this command to ensure that types for cypress are accessible by typescript. these types depends on dom and es6 so we pass them as lib option to typescript.
npx tsc --init --types cypress --lib dom,es6

npx is used to run npm command in the local folder.
5. to open cypress: use command: npx cypress open
(after that cypress folder will be seen in the side bar)

To write test: steps :
6. /// <reference types = "cypress" />
we use this because we telling the program to allow autocompletion 
in this script/ file from the 
cypress library or cypress node package so it becomes very handy and useful.

##. to write a test, we need a test runner - mocha
mocha comes inbuild with cypress.
(you do not need to install other test runner)

7. write test function: use "it" function/block

it("name of the test", function(){
   type cypress comands... 
   cy.visit('link of the website')
})

8. then run test using : npx cypress open
or
node_modules/.bin/cypress open

9. to terminate the program use: ctrl c

## to run the test on every changes write:
"watchForFileChanges":false 
in cypress.json file.
("watchForFileChanges":true) is set to bydefault.

10. to Access the elements: locators
#L2AGLb > .QS5gu
---> # means id
---> . means class

11. Access elements with text (instead of putting locators): 
cy.contains('All news about Sweden | Euronews').click()

12. if you use "only" property to a TC it means it will run those specific TC only.

13. add  {timeout: 6000} The first period waits for a matching request then run the code.
// default timeout is 4 secs

14. for taking screenshot:

it('Take a Screenshot', () => {
       cy.screenshot()
 })

 15. for running specific file:

 -----> npx cypress run  --spec "cypress/integration/login_Test.js" 
------> npx cypress run -- spec "project2/cypress/integration/eCommerce_demoTest.js"    
(copy relative path of the file)  

 16. click({force: true}) means click forsefully.
 
 17.  Run Cypress Tests in Test Runner & Terminal :
 >>>> npx cypress open (to open test runner)
 >>>> npx cypress run (to run all the tests under integration folder in headless mode)
>>>> npx cypress run --headed (with --headed parameters we can see the execution or ui in the browser.)
 
 18. headless means all TCs are executed in the backend.
 so we can not see any UI. 

 19. to run all the tests under integration folder using Chrome:

 npx cypress run --browser chrome

npx cypress run --headed --browser chrome

20. Scroll the window 500px down 

cy.scrollTo(0, 500) 

21. {forse : true}
    click('bottomLeft', { multiple: true })

    /// cy.click() can only be called on a single element.
     Your subject contained 13 elements. Pass { multiple: true } if you want to 
    serially click each element

22. Handling alert:

>> cypress by default take care of (close ) alert window.
>> it close the window without doing any manual action.
>>  we donot need to use any tool, or write any additional code/script for closing alert box.

>>>>>  but sometime, if you want to varify or validate something like messages in alert window, then
you have to write some piece of code.
(to create an event)

** expect(str).to.equal or expect(str).to.contain


1. window:alert (OK button on the alert gets clicked automatically)
----------------
 cy.on('window:alert',(str)=>{
         //assertions
 expect(t).to.contains('Your full name');
 })

----> (window:alert) event will capture the message to the particular variable (str)
----> str is a variable

2. window:confirm (The following confirmation pop-up with "OK" and "Cancel" buttons getting displayed.)
------------------
cy.on("window:confirm", (t) => {
         //verify text on pop-up
         expect(t).to.equal("message expecting");
      });

**** Implementation Cancel click:

after visit url script, place this code:

cy.on("window:confirm", (s) => {
         return false;
      });

then write get and click commands.
next script will be for verify Cancel click.

// verify application message on Cancel button click
      cy.get('#result').should('have.text', 'You clicked: Cancel')
   });

23. Handling Navigation with go() command.
 it contains 2 keywords:
   back and forward.

"back" is also represented by -1.
and "forward" is by 1.


It moves forward or backward to the next or previous URL in browser history.

The usage is as follows âˆ’

//like clicking back button
cy.go('back')
//like clicking forward button
cy.go('forward')



24. cy.reload() ---> used to refresh the package

25. // viewport to 100px and 500px
      
        cy.viewport(1000, 800)

26. Hooks:

   1. before : runs/executed once before all tests
   2. after : runs once all tests are done
   3. beforeEach : runs before every test block
   4. afterEach : runs after every test block

27. Fixture : it is a file that contains some data.
and that particular data, we use in our TCs.
it is besically a data driven test.

i.e test will be driven by the data.
data can be in diff format like json, png, video,gif,txt etc.

28. POM : it is a design patterns where page objects are seperated 
from test scripts.
in pom, we create a seperate classes for each and every pages of the application.
and those classes having locators.

>> pom is useful in duplication and update.
>> add variables to replace hard code locators.

features: we can POM for 
1.reusability (we can reuse the class in multiple TCs)
2. maintainability
